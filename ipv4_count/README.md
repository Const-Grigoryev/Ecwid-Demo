IPv4 Count
==========

Дан простой текстовый файл с IPv4 адресами. Одна строка – один адрес, примерно так:

```
145.67.23.4
8.34.5.23
89.54.3.124
89.54.3.124
3.45.71.5
...
```

Файл в размере не ограничен и может занимать десятки и сотни гигабайт.

Необходимо посчитать количество __уникальных адресов__ в этом файле, затратив как можно меньше памяти и времени.
Существует "наивный" алгоритм решения данной задачи (читаем строка за строкой, кладем строки в HashSet), желательно
чтобы ваша реализация была лучше этого простого, наивного алгоритма.

Немного деталей:
- По всем вопросам смело писать на join@ecwid.com
- Использовать можно только возможности стандартной библиотеки Java/Kotlin
- Писать нужно на Java (версия 11 и выше) или Kotlin.
- В задании должен быть рабочий метод main(), это должно быть готовое приложение, а не просто библиотека
- Сделанное задание необходимо разместить на GitHub

---
Прежде чем отправить задание, имеет смысл проверить его вот на этом [файле](https://ecwid-vgv-storage.s3.eu-central-1.amazonaws.com/ip_addresses.zip).
Внимание – файл весит около 20Gb, а распаковывается приблизительно в 120Gb.


Заметки по реализации
---------------------

1. Программу можно использовать как в режиме пользовательского приложения (класс `IPv4CountApp`), так и в режиме
   библиотеки (класс `IPv4Count`). Класс `IPv4CountApp` сам по себе занимается только соблюдением протокола ОС,
   а всю реальную работу делегирует движку `IPv4Count`.
   
2. Общий интерфейс приложения соответствует таковому для большинства Unix-утилит:
     - входом по умолчанию является стандартный поток ввода;
     - результат печатается в стандартный поток вывода;
     - ошибки, буде они случатся, валятся в `STDERR`;
     - поддерживаются разные коды завершения: 0 — всё прошло относительно гладко, -1 — случилась фатальная ошибка.

3. Сердцем алгоритма является класс `BitScale`. Логически он представляет собой массив булевых значений, каждое из
   которых соответствует одному возможному адресу из пространства IPv4: «истина» означает, что адрес присутствует
   в просмотренной части списка, «ложь» — что отсутствует. Физически эти значения упакованы в «слова» по 64 штуки.
   Поскольку объём адресного пространства IPv4 составляет 2<sup>32</sup>, весь битовый массив имеет размер
   2<sup>29</sup> байт, или 512 Мб.
   
4. Хотя 512 Мб вполне влезает в память современных машин, дизайн кода допускает замену битового массива какой-нибудь
   более экономной структурой данных, например, [фильтром Блума][Bloom_filter]. При этом удастся получить выигрыш
   в потреблении памяти (и, вероятно, быстродействии — благодаря уменьшению количества cache misses), пожертвовав
   точностью подсчёта.

5. Класс `BitScale` можно расширить, добавив методы для его представления в виде стандартного списка `List<Boolean>`
   или множества `Set<Long>`. Для данной задачи это не нужно, так как потребует большого количества дополнительной
   работы. Однако такой задел на будущее оставлен намеренно: эта структура данных довольно универсальна и хорошо
   подходит для повторного использования.

6. Другой важный компонент — парсер IP-адресов `IPv4Parser`. Он выполнен на [конечном автомате][Finite_state_machine],
   построенном вручную — это традиционное, хорошо зарекомендовавшее себя решение для такого рода задач. Альтернативами
   могли бы быть:
     - использование ANTLR или аналогичного инструмента для генерации кода;
     - библиотека [комбинаторных парсеров][Parser_combinator];
     - [рекурсивный парсер][Recursive_descent_parser];
     - спагетти-парсер.
     
7. Так как по условию утилита должна спокойно переваривать файлы размером 120 Гб (то есть около 8 млрд. строк),
   создавать временные объекты на каждой строке *крайне* нежелательно: это слишком сильно нагрузит сборщик мусора.
   Поэтому парсер написан в несколько старомодном C-подобном стиле, с изменяемыми переменными, управляющими флагами,
   колбэками и большим `switch`-ем внутри. В том числе, я сознательно избегал использования `String` и метода
   `Reader.readLine`, который для каждой строчки входного файла создаёт по объекту, а то и по два: собственно `String`
   и массив символов в нём. В итоге ни единого `new` в основном цикле парсера! (*N.B.* К сожалению, я не могу ручаться
   за другой библиотечный код. Вполне вероятно, что где-то в недрах UTF-кодека временные объекты всё жё создаются, но
   написание собственного декодера для Юникода явно выходит за рамки задачи. В любом случае я рассчитываю, что
   стандартный декодер уже отлично оптимизирован, поскольку работать с текстовыми файлами приходится буквально
   в каждом приложении).
   
8. Строго говоря, перфекционистская цель в $O(1)$ аллокаций достигнута не была: один временный объект создаётся каждый
   раз при заполнении буфера в `LineNumberReader` (в методе `StreamDecoder.implRead`). Поэтому, с учётом типичного
   размера задачи, буфер был увеличен до 1 млн. символов. В результате файл размером 120 Гб порождает всего 120 тыс.
   временных объектов — вполне достойный результат. При этом сохраняется ещё ресурс для оптимизации: в крайнем случае,
   можно пожертвовать универсальностью, выкинуть все эти устаревшие `Reader`-ы с `InputStream`-ами и читать прямо из
   `FileChannel`.
   

Что дальше?
-----------

Как можно улучшить код или дополнить функционал утилиты:

[ ] Поддержка разных кодировок. Со стороны пользователя это будет выглядеть как необязательный параметр командной
    строки: `-e cp1251`, например. Заодно кодировку по умолчанию сменить на более легковесную однобайтовую самоделку,
    в которой были бы только цифры, точки и переводы строк.
   
[ ] Прямое чтение из файла (или нескольких), а не из `STDIN`. Опять же, как параметры командной строки: `file1.txt
    file2.txt file3.txt`. Может быть, стоит замаппить файл в память, — вдруг это даст какой-то выигрыш в скорости?
    Последнее, конечно, нужно выяснять экспериментальным путём.

[ ] Расширенный синтаксис. Разрешить комментарии и пробельные символы, ~~поддержать IPv6~~ (хотя нет, для этого
    придётся переделывать `BitScale`). Короче, тут есть где разгуляться фантазии.

[ ] Редизайн интерфейса `IPv4Parser`. Имеющаяся сигнатура `parseLine` не отражает тот факт, что концептуально
    результат парсинга является типом-суммой:
    ```haskell
    data ParseResult = Address Int | Error String | BlankLine | EndOfFile
    ```
    Объединение `ParseResult` и `IPv4Builder` в один *visitor* позволит исправить этот недочёт.

[ ] Отображать номер строчки в сообщении об ошибке. Заодно нужно будет пофиксить баг, связанный с переполнением
    счётчика строк в `LineNumberReader`.


[Bloom_filter]: https://en.wikipedia.org/wiki/Bloom_filter
[Finite-state_machine]: https://en.wikipedia.org/wiki/Finite-state_machine
[Parser_combinator]: https://en.wikipedia.org/wiki/Parser_combinator
[Recursive_descent_parser]: https://en.wikipedia.org/wiki/Recursive_descent_parser