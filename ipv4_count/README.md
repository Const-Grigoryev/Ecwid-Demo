IPv4 Count
==========

_Switch to the [:us: English version](./README_en.md)._


[Задача](https://github.com/Ecwid/new-job/blob/master/IP-Addr-Counter.md)
-------------------------------------------------------------------------

> Дан простой текстовый файл с IPv4 адресами. Одна строка – один адрес, примерно так:
> 
>     145.67.23.4
>     8.34.5.23
>     89.54.3.124
>     89.54.3.124
>     3.45.71.5
>     ...
> 
> Файл в размере не ограничен и может занимать десятки и сотни гигабайт.
> 
> Необходимо посчитать количество __уникальных адресов__ в этом файле, затратив как можно меньше памяти и времени.
> Существует "наивный" алгоритм решения данной задачи (читаем строка за строкой, кладем строки в `HashSet`), желательно
> чтобы ваша реализация была лучше этого простого, наивного алгоритма.
> 
> Немного деталей:
>   - По всем вопросам смело писать на join-ecom@lightspeedhq.com
>   - Использовать можно только возможности стандартной библиотеки Java/Kotlin
>   - Писать нужно на Java (версия 17 и выше) или Kotlin.
>   - В задании должен быть рабочий метод `main()`, это должно быть готовое приложение, а не просто библиотека
>   - Сделанное задание необходимо разместить на GitHub
> 
> ---
> 
> Прежде чем отправить задание, имеет смысл проверить его вот на этом [файле](https://ecwid-vgv-storage.s3.eu-central-1.amazonaws.com/ip_addresses.zip).
> Внимание – файл весит около 20Gb, а распаковывается приблизительно в 120Gb.


Использование
-------------

```shell
ipv4_count [FILE...]
```

`FILE` — один или несколько входных файлов. При запуске без параметров программа начинает работать в диалоговом
режиме, считывая данные из стандартного потока ввода (с клавиатуры). 


Заметки по реализации
---------------------

1. Программу можно использовать как в режиме пользовательского приложения (класс `IPv4CountApp`), так и в режиме
   библиотеки (класс `IPv4Count`). Класс `IPv4CountApp` сам по себе занимается только соблюдением протокола ОС,
   а всю реальную работу делегирует движку `IPv4Count`.
   
2. Общий интерфейс приложения соответствует таковому для большинства Unix-утилит:
     - имя входного файла передаётся в командной строке, а если оно не указано, входом по умолчанию становится
       стандартный поток ввода;
     - результат печатается в стандартный поток вывода;
     - ошибки, буде они случатся, валятся в `STDERR`;
     - поддерживаются разные коды завершения: 0 — всё прошло относительно гладко, –1 — случилась фатальная ошибка,
       –2 указывает на некорректные значения параметров командной строки.

3. Программа работает в одном потоке, и это осознанное архитектурное решение. Измерения показывают, что на имеющемся
   в моём распоряжении железе в IO-heavy задаче существенного выигрыша от распараллеливания не получить (см. бенчмарк
   `BP01_Concurrent`). Теоретически, сама задача хорошо подходит для стратегии типа «разделяй и властвуй», и такое
   решение возможно в рамках эксперимента, но вряд ли целесообразно.

4. Сердцем алгоритма является класс `BitScale`. Логически он представляет собой массив булевых значений, каждое из
   которых соответствует одному возможному адресу из пространства IPv4: «истина» означает, что адрес присутствует
   в просмотренной части списка, «ложь» — что отсутствует. Физически эти значения упакованы в «слова» по 64 штуки.
   Поскольку объём адресного пространства IPv4 составляет 2³², весь битовый массив имеет размер 2²⁹ байт, или 512 МБ.
   
5. Хотя 512 МБ вполне влезает в память современных машин, дизайн кода допускает замену битового массива какой-нибудь
   более экономной структурой данных, например, [фильтром Блума][Bloom_filter]. При этом удастся получить выигрыш
   в потреблении памяти (и, вероятно, быстродействии — благодаря уменьшению количества cache misses), пожертвовав
   точностью подсчёта.

6. Класс `BitScale` можно расширить, добавив методы для его представления в виде стандартного списка `List<Boolean>`
   или множества `Set<Long>`. Для данной задачи это не нужно, так как потребует большого количества дополнительной
   работы. Однако такой задел на будущее оставлен намеренно: эта структура данных довольно универсальна и хорошо
   подходит для повторного использования.

7. Другой важный компонент — парсер IP-адресов. Он выполнен на [конечном автомате][Finite_state_machine], построенном
   вручную — это традиционное, хорошо зарекомендовавшее себя решение для такого рода задач. Альтернативами
   могли бы быть:
     - использование ANTLR или аналогичного инструмента для генерации кода;
     - библиотека [комбинаторных парсеров][Parser_combinator];
     - [рекурсивный парсер][Recursive_descent_parser];
     - спагетти-парсер.
   
8. Парсер написан в несколько старомодном C-подобном стиле, с изменяемыми переменными, управляющими флагами и большим
   `switch`-ем внутри. Выглядит страшновато, но эта жуть инкапсулирована в одном-единственном методе и не портит стиль
   кода остальной части проекта. Зато удалось вообще не нагружать garbage collector во время работы, что вместе
   с другими низкоуровневыми оптимизациями обеспечило парсинг одного адреса меньше чем за 50 нс (см. `BC02_Parser`).


Что дальше?
-----------

Как можно улучшить код или дополнить функционал утилиты:

- [ ] Полноценный интерфейс командной строки. Как минимум, опции `-h` и `-v` должны присутствовать в каждой программе.

- [ ] Поддержка разных кодировок. Со стороны пользователя это будет выглядеть как необязательный параметр командной
  строки: `-e cp1251`, например. (**UPD:** чем дальше, тем более это затруднительно)

- [ ] Добавить возможность перечисления файлов по маске: `./foo/*.txt`.

- [ ] Ещё одна полезная опция: флажок, включающий fail-fast режим.

- [ ] Расширенный синтаксис. Разрешить комментарии и пробельные символы, ~~поддержать IPv6~~ (хотя нет, для этого
  придётся переделывать `BitScale`). Короче, тут есть где разгуляться фантазии.

- [ ] Отображать номер строчки в сообщении об ошибке.

- [ ] Более детальные сообщения об ошибках. Сейчас, по сути, их всего три вида:
    - **Invalid octet value** — переполнение октета, семантическая ошибка;
    - **Malformed address (too short)** — строчка содержит меньше четырёх октетов, синтаксическая ошибка;
    - **Unexpected character** — любая другая ошибка в синтаксисе.

- [ ] В порядке эксперимента: обработка файла в несколько потоков (с помощью `ForkJoinPool` и `FileChannel.map`,
  например). Неясно, правда, будет ли с этого хоть какой-то практический выхлоп.


Бенчмаркинг
-----------

Тестирование проводилось на машине со следующей конфигурацией:

  - Intel i7-4500U CPU (4 cores @ 1.80 GHz);
  - 8 GB RAM (DDR3 1600 MHz);
  - 2 TB SATA-III SSD;
  - Microsoft Windows 10 + OpenJDK 22.0.2+9-70 (64-bit);
  - Ubuntu Linux 23.10.1 + OpenJDK 22-ea+16-Ubuntu-1 (64-bit).

Для оценки быстродействия утилиты и отдельных её частей в различных режимах я написал несколько бенчмарков. Главный
из них называется `BI02_Performance` и измеряет общее время выполнения программы при чтении физического файла,
содержащего 500 млн. адресов[^dataset-excuses]. Согласно экспериментам, в Windows оно составляет 62–65 с, в Linux
65–71 с. В более привычных терминах это означает производительность около **105 МБ/с**, или 130 нс на строчку.

[^dataset-excuses]: Технические ограничения не позволяют использовать для тестов файл, предложенный в условии —
у меня просто нет столько свободного места. Тем не менее и 500 млн. адресов (6.64 ГБ) вполне достаточно, чтобы оценить
общую производительность. Единственная проблема состоит в том, что на таких объёмах может быть заметно влияние кэша
файловой системы, поэтому для получения более реалистичных результатов бенчмарки не следует запускать несколько раз
подряд.


[Bloom_filter]: https://en.wikipedia.org/wiki/Bloom_filter
[Finite_state_machine]: https://en.wikipedia.org/wiki/Finite-state_machine
[Parser_combinator]: https://en.wikipedia.org/wiki/Parser_combinator
[Recursive_descent_parser]: https://en.wikipedia.org/wiki/Recursive_descent_parser
