IPv4 Count
==========

Дан простой текстовый файл с IPv4 адресами. Одна строка – один адрес, примерно так:

```
145.67.23.4
8.34.5.23
89.54.3.124
89.54.3.124
3.45.71.5
...
```

Файл в размере не ограничен и может занимать десятки и сотни гигабайт.

Необходимо посчитать количество __уникальных адресов__ в этом файле, затратив как можно меньше памяти и времени.
Существует "наивный" алгоритм решения данной задачи (читаем строка за строкой, кладем строки в HashSet), желательно
чтобы ваша реализация была лучше этого простого, наивного алгоритма.

Немного деталей:
- По всем вопросам смело писать на join@ecwid.com
- Использовать можно только возможности стандартной библиотеки Java/Kotlin
- Писать нужно на Java (версия 11 и выше) или Kotlin.
- В задании должен быть рабочий метод main(), это должно быть готовое приложение, а не просто библиотека
- Сделанное задание необходимо разместить на GitHub

---
Прежде чем отправить задание, имеет смысл проверить его вот на этом [файле](https://ecwid-vgv-storage.s3.eu-central-1.amazonaws.com/ip_addresses.zip).
Внимание – файл весит около 20Gb, а распаковывается приблизительно в 120Gb.


Заметки по реализации
---------------------

1. Программу можно использовать как в режиме пользовательского приложения (класс `IPv4CountApp`), так и в режиме
   библиотеки (класс `IPv4Count`). Класс `IPv4CountApp` сам по себе занимается только соблюдением протокола ОС,
   а всю реальную работу делегирует движку `IPv4Count`.
   
2. Общий интерфейс приложения соответствует таковому для большинства Unix-утилит:
     - имя входного файла передаётся в командной строке, а если оно не указано, входом по умолчанию становится
       стандартный поток ввода;
     - результат печатается в стандартный поток вывода;
     - ошибки, буде они случатся, валятся в `STDERR`;
     - поддерживаются разные коды завершения: 0 — всё прошло относительно гладко, –1 — случилась фатальная ошибка,
       –2 указывает на некорректные значения параметров командной строки.

3. Программа работает в одном потоке, и это осознанное архитектурное решение. Теоретически, сама задача хорошо подходит
   для распараллеливания, но произвольный доступ к файлу, необходимый для этого, может быть медленнее последовательного
   в 2–10 раз (это зависит от модели установленного SSD, в моём случае, скорее, ближе ко второй цифре). Такое
   замедление сведёт на нет весь потенциальный выигрыш от распараллеливания. В целом, многопоточное решение возможно
   в рамках эксперимента, но вряд ли целесообразно.

4. Сердцем алгоритма является класс `BitScale`. Логически он представляет собой массив булевых значений, каждое из
   которых соответствует одному возможному адресу из пространства IPv4: «истина» означает, что адрес присутствует
   в просмотренной части списка, «ложь» — что отсутствует. Физически эти значения упакованы в «слова» по 64 штуки.
   Поскольку объём адресного пространства IPv4 составляет 2³², весь битовый массив имеет размер 2²⁹ байт, или 512 МБ.
   
5. Хотя 512 МБ вполне влезает в память современных машин, дизайн кода допускает замену битового массива какой-нибудь
   более экономной структурой данных, например, [фильтром Блума][Bloom_filter]. При этом удастся получить выигрыш
   в потреблении памяти (и, вероятно, быстродействии — благодаря уменьшению количества cache misses), пожертвовав
   точностью подсчёта.

6. Класс `BitScale` можно расширить, добавив методы для его представления в виде стандартного списка `List<Boolean>`
   или множества `Set<Long>`. Для данной задачи это не нужно, так как потребует большого количества дополнительной
   работы. Однако такой задел на будущее оставлен намеренно: эта структура данных довольно универсальна и хорошо
   подходит для повторного использования.

7. Другой важный компонент — парсер IP-адресов. Деталям его реализации посвящена [отдельная глава](#парсер-ip-адресов).
   Принципиально лишь то, что он выполнен на [конечном автомате][Finite_state_machine], построенном вручную — это
   традиционное, хорошо зарекомендовавшее себя решение для такого рода задач. Альтернативами могли бы быть:
     - использование ANTLR или аналогичного инструмента для генерации кода;
     - библиотека [комбинаторных парсеров][Parser_combinator];
     - [рекурсивный парсер][Recursive_descent_parser];
     - спагетти-парсер.
   
8. Для перекодирования бинарного входного потока в текст используется самодельный `LightweightInputStreamReader`.
   Он гораздо быстрее, чем стандартный `InputStreamReader`, за счёт отказа от поддержки разнообразных кодировок
   и возможности работы в многопоточном окружении. Он также не требует никаких дополнительных аллокаций при чтении
   (за исключением методов, читающих в массив, которыми я всё равно не пользуюсь). Единственная фича, которая в нём
   есть, — унификация различных символов разрыва строки, — сохранена ради преемственности с предыдущей версией,
   использовавшей `LineNumberReader`. 


### Парсер IP-адресов

#### Дизайн парсера: реализация

При разработке парсера основной акцент был сделан на скорость его работы. Такая расстановка приоритетов заставила
избегать высокоуровневых абстракций и чрезвычайно внимательно относиться к расходованию памяти. 

Так как по условию утилита должна спокойно переваривать файлы размером 120 ГБ (то есть около 8 млрд. строк),
создавать временные объекты в основном цикле программы было бы *крайне* нежелательно: даже один такой объект на строчку
слишком сильно нагрузил бы сборщик мусора. В частности, я сознательно отказался от стандартного `String`-а и очень
удобного в других обстоятельствах метода `Reader.readLine`. Ведь он при каждом вызове создаёт по объекту, а то и по два:
собственно `String` и массив символов в нём!

В итоге парсер пришлось писать в несколько старомодном C-подобном стиле, с изменяемыми переменными, управляющими
флагами, колбэками и большим `switch`-ем внутри. Поэтому в коде непросто разобраться с первого взгляда, даже
несмотря на подробные комментарии, что может затруднить его поддержку. Зато с точки зрения расхода памяти парсер
безупречен: в основном цикле моего кода нет ни единого `new`!

К сожалению, того же нельзя сказать про библиотечный код. Во-первых, стандартный `InputStreamReader` внутри себя
всё-таки создаёт один небольшой объект при каждом заполнении буфера. Во-вторых, он сам по себе довольно медленный
из-за необходимости переноса данных между разнотипными буферами. Для решения этой проблемы я просто написал свой
`LightweightInputStreamReader` минимальным набором методов.

Наиболее спорным местом остаётся взаимодействие парсера с `Reader`-ом. Парсер запрашивает символы по одному, что
означает, что резолвинг виртуального метода `Reader.read` и обновление состояния всей цепочки объектов, стоящих за
парсером, происходят *на каждом байте* входных данных. Не то чтобы это представляло какую-то проблему для современных
Java-машин, но раз уж начал заниматься микрооптимизациями, то становится сложно остановиться. Пока что я придерживаюсь
мнения, что универсальность и читаемость кода оправдывают жертву в 10–15% перформанса.


#### Дизайн парсера: интерфейс

Парсер был переосмыслен с момента прошлого релиза. Если там парсер — отдельный класс с не вполне понятным состоянием,
то сейчас парсер — это отдельный метод `parseLine`, подмешанный к `IPv4LineVisitor` (в Kotlin я бы сделал extension
method). Причем здесь visitor? Сейчас объясню.

В принципе, задача парсера состоит в классификации каждой строчки входного файла как корректной (содержащей валидный
IP-адрес), некорректной (содержащей синтаксическую ошибку или просто не имеющей отношения к делу текст) или просто
пустой. В функциональных языках для такого рода классификаций используют тип-сумму и pattern matching, в ООП —
наследование классов и [паттерн *visitor*][Visitor_pattern]. *Visitor* — это наш «pattern matching дома», причём
особенно его любят именно в контексте парсинга и разного прочего компиляторостроения, хотя область его применения
этим не ограничивается. С практической же точки зрения, visitor («посетитель») — просто объект, содержащий по методу
на каждый из вариантов, допустимых классификацией, а сам акт классификации («посещение») всегда сводится к вызову
одного (и только одного!) из этих методов.

Однако вопреки тому, что пишут в книжках, visitor-у совершенно необязательно работать с объектами из одной иерархии.
Вполне достаточно того, чтобы у них было какое-нибудь единое представление, которое можно анализировать; например,
в виде текстовой строки. Это как раз наш случай: метод `parseLine` считывает одну строчку, разбирает и классифицирует
её и вызывает, в зависимости от результата, один из методов-продолжений[^continuation] `address`, `mistake` или
`nothing`. Никакой промежуточный объект при этом создавать не требуется! (Помните про цель добиться нуля аллокаций
на строчку?)

[^continuation]: Ещё одно умное слово. *Visitor* — это пример техники под названием [continuation-passing style (CPS)][Continuation-passing_style],
когда функция (в нашём случае `parseLine`) не возвращаёт значение напрямую, а спрашивает вызывающую сторону, что та
собиралась делать с ним, и делает это сама. Вот это «что вы собираетесь делать с результатом» и называется
_продолжением_ (continuation). На самом деле, продолжение — это обычный колбэк, который просто передаётся в функцию
дополнительным параметром; отсюда, собственно, и название. У нас продолжений несколько, и передаются они через `this`,
но суть всё равно та же. Кстати, через CPS можно эмулировать и другие фичи, которых нет в вашем любимом языке: ленивые
вычисления, исключения, кортежи, корутины, даже монады. Более того, зачастую даже в языках, в которых эти фичи есть,
под капотом они именно так и работают!

С другой стороны, *visitor* достаточно гибок, чтобы при необходимости *можно* было создать объект, представляющий
строчку с адресом, любого вида. Это открывает возможности для переиспользования кода. Например, если нам потребуется
неизменяемое представление, можно реализовать интерфейс `IPv4LineVisitor` в фабрике или билдере. Даже никакие адаптеры
не нужны: методы-продолжения суть *в точности* фабричные методы или методы, конфигурирующие билдер (см. пример кода
в тесте [*VisitorTest.kt*](src/test/kotlin/dev/aspid812/ipv4_count/impl/VisitorTest.kt#L16)).
А в данном проекте используется изменяемое представление `MutableIPv4Line`: в нём продолжения являются обычными
setter-ами.

Пару слов о недостатках такой реализации. Пуристы могут обратить внимание, что у нас каждая строчка требует вызова
двух интерфейсных методов, и один из них почти наверняка не будет оптимизирован виртуальной машиной. Причём очевидно,
что в поставленной задаче можно обойтись и без этого. Что ж, действительно, я рассматривал альтернативный вариант
дизайна, в котором парсер упаковывал прочитанный адрес и код ошибки в один `long` и просто возвращал его `return`-ом.
Но мне так и не удалось получить от него статистически значимый прирост производительности, и я решил, что несколько
потенциально сэкономленных тактов процессора не стоят того, чтобы отказываться от универсальности решения и гарантий,
предоставляемых системой типов.


Что дальше?
-----------

Как можно улучшить код или дополнить функционал утилиты:

- [ ] Поддержка разных кодировок. Со стороны пользователя это будет выглядеть как необязательный параметр командной
  строки: `-e cp1251`, например.

- [X] Кодировку по умолчанию сменить на более легковесную однобайтовую самоделку, в которой были бы только цифры, точки
  и переводы строк. Потенциально, это может очень сильно забустить производительность. *UPD:* сделано в v1.1, ускорение
  декодера ×3.4, общее ускорение ×2.

- [ ] Полноценный интерфейс командной строки. Как минимум, опции `-h` и `-v` должны присутствовать в каждой утилите.

- [ ] Добавить возможность перечисления файлов по маске: `./foo/*.txt`.

- [ ] Ещё одна полезная опция: флажок, включающий fail-fast режим.

- [X] Прямое чтение из файла (или нескольких), а не из `STDIN`. Опять же, как параметры командной строки: `file1.txt
  file2.txt file3.txt`. **UPD:** сделано в v2.0.

- [X] Миграция на NIO. В ходе экспериментов выяснилось, что даже простое последовательное чтение из `FileChannel`
  в несколько раз превосходит по скорости `InputStream`. Придётся перекроить API (опять!), но такую возможность нельзя
  упускать. **UPD:** сделано в v2.0.

- [ ] После этого можно будет поэкспериментировать с более продвинутыми техниками: прямым маппингом файлов в память,
  параллельным чтением в несколько потоков, двойной буферизацией. Однако усилий это потребует колоссальных, а будет ли
  хоть какой-то практический выхлоп, неясно.

- [ ] Расширенный синтаксис. Разрешить комментарии и пробельные символы, ~~поддержать IPv6~~ (хотя нет, для этого
  придётся переделывать `BitScale`). Короче, тут есть где разгуляться фантазии.

- [ ] Более детальные сообщения об ошибках. Сейчас, по сути, их всего три (*UPD:* а было-то два — прогресс!):
    - **Invalid octet value** — переполнение октета, семантическая ошибка;
    - **Malformed address (too short)** — строчка содержит меньше четырёх октетов, синтаксическая ошибка;
    - **Unexpected character** — любая другая ошибка в синтаксисе.

- [X] Редизайн интерфейса `IPv4Parser`. Претензии к существующему дизайну и варианты их разрешения обсуждаются
  в [соответствующем разделе](#дизайн-парсера-интерфейс). *UPD:* сделано в v1.1.

- [ ] Отображать номер строчки в сообщении об ошибке.

- [X] Рефакторинг конечного автомата. Пока что смысл `State`-ов остаётся немного туманным, и неочевидно, почему
  выполняются инварианты. *UPD:* сделано в v1.1.

- [X] Рефакторинг бенчмарков. В первой версии иерархия классов получилась очень запутанной, имеет смысл группировать
  бенчмарки по типу входных данных, а не по use case.


Бенчмаркинг
-----------

Бенчмаркинг в данной задаче преследует две цели: оценить производительность программы на файлах большого объёма
(около 120 ГБ) и выявить места для дальнейшей оптимизации. Соответственно, бенчмарки разделены на две большие группы:
«интегральные» измеряют время работы программы в целом, «компонентные» — её отдельных частей.

Тестирование проводилось на машине со следующей конфигурацией:

  - Intel i7-4500U CPU (4 cores @ 1.80 GHz);
  - 8 GB RAM (DDR3 1600 MHz);
  - 2 TB SATA-III SSD;
  - Microsoft Windows 10 + HotSpot JVM 17.0.11 (64-bit);
  - Ubuntu Linux 23.10.1 + OpenJDK 17.0.9-ea (64-bit).


### Интегральные бенчмарки

<details>
<summary>Сырые данные</summary>

#### Windows

    Benchmark                             (lines)  Mode  Cnt     Score      Error  Units
    BI01_ModesComparison.v1_application        1K    ss    3   526.305 ±  456.617  ms/op
    BI01_ModesComparison.v1_application       25K    ss    3   576.684 ±  482.529  ms/op
    BI01_ModesComparison.v1_application        1M    ss    3   850.891 ±  616.703  ms/op
    BI01_ModesComparison.v1_application       16M    ss    3  4914.700 ± 2268.497  ms/op
    BI01_ModesComparison.v2_library_file       1K    ss    3   186.820 ± 2389.843  ms/op
    BI01_ModesComparison.v2_library_file      25K    ss    3   198.594 ± 2329.460  ms/op
    BI01_ModesComparison.v2_library_file       1M    ss    3   604.217 ± 2453.587  ms/op
    BI01_ModesComparison.v2_library_file      16M    ss    3  6703.343 ± 3889.305  ms/op
    BI01_ModesComparison.v3_library_nio        1K    ss    3   198.943 ± 2328.769  ms/op
    BI01_ModesComparison.v3_library_nio       25K    ss    3   204.976 ± 2303.023  ms/op
    BI01_ModesComparison.v3_library_nio        1M    ss    3   512.853 ± 2874.778  ms/op
    BI01_ModesComparison.v3_library_nio       16M    ss    3  3682.182 ± 1491.631  ms/op
    BI01_ModesComparison.v4_library_gen        1K    ss    3   205.221 ± 2893.392  ms/op
    BI01_ModesComparison.v4_library_gen       25K    ss    3   229.996 ± 3101.076  ms/op
    BI01_ModesComparison.v4_library_gen        1M    ss    3   560.788 ± 2247.992  ms/op
    BI01_ModesComparison.v4_library_gen       16M    ss    3  4669.722 ± 3487.058  ms/op
    BI02_Performance.v1_measure                1K    ss          0.396              s/op
    BI02_Performance.v1_measure               25K    ss          0.422              s/op
    BI02_Performance.v1_measure                1M    ss          0.707              s/op
    BI02_Performance.v1_measure               16M    ss          4.700              s/op
    BI02_Performance.v1_measure              200M    ss         51.776              s/op
    BI02_Performance.v1_measure                8B    ss       2050.160              s/op

#### Linux

    Benchmark                             (lines)  Mode  Cnt     Score     Error  Units
    BI01_ModesComparison.v1_application        1K    ss    5   414.279 ±  55.501  ms/op
    BI01_ModesComparison.v1_application       25K    ss    5   434.475 ±  55.246  ms/op
    BI01_ModesComparison.v1_application        1M    ss    5   714.680 ± 221.544  ms/op
    BI01_ModesComparison.v1_application       16M    ss    5  4369.405 ± 266.826  ms/op
    BI01_ModesComparison.v2_library_file       1K    ss    5   147.424 ± 385.604  ms/op
    BI01_ModesComparison.v2_library_file      25K    ss    5   161.308 ± 413.564  ms/op
    BI01_ModesComparison.v2_library_file       1M    ss    5   543.882 ± 457.878  ms/op
    BI01_ModesComparison.v2_library_file      16M    ss    5  6199.169 ± 526.020  ms/op
    BI01_ModesComparison.v3_library_nio        1K    ss    5   149.730 ± 406.366  ms/op
    BI01_ModesComparison.v3_library_nio       25K    ss    5   160.191 ± 406.814  ms/op
    BI01_ModesComparison.v3_library_nio        1M    ss    5   370.087 ± 442.962  ms/op
    BI01_ModesComparison.v3_library_nio       16M    ss    5  2840.922 ± 712.801  ms/op
    BI01_ModesComparison.v4_library_gen        1K    ss    5   157.163 ± 490.698  ms/op
    BI01_ModesComparison.v4_library_gen       25K    ss    5   263.701 ± 537.743  ms/op
    BI01_ModesComparison.v4_library_gen        1M    ss    5   528.951 ± 576.986  ms/op
    BI01_ModesComparison.v4_library_gen       16M    ss    5  4356.788 ± 161.311  ms/op
    BI02_Performance.v1_measure                1K    ss          0.377             s/op
    BI02_Performance.v1_measure               25K    ss          0.398             s/op
    BI02_Performance.v1_measure                1M    ss          0.672             s/op
    BI02_Performance.v1_measure               16M    ss          4.278             s/op
    BI02_Performance.v1_measure              200M    ss         49.379             s/op
    BI02_Performance.v1_measure                8B    ss       1923.779             s/op

</details>

Специально для бенчмаркинга был написан генератор случайных адресов, который имитирует реальный файл с IP-адресами
(использование реального файла актуального размера превосходит мои технические возможности). Кроме того, так как
JMH не предназначен тестирования отдельных приложений, во время измерений счётчик функционирует в режиме библиотеки.
Чтобы уловить разницу между этими режимами работы, я написал отдельный набор бенчмарков (`BI01_ModesComparison`).
Он позволяет сравнить поведение программы при разных сценариях использования (как приложение, запущенное отдельным
процессом, и как библиотека), на разных источниках (генератор или реальный файл) и объёмах входа (до 16 млн. строк,
т.е. до 240 МБ). И хотя полученные данные довольно сильно загрязнены шумом, они позволяют подтвердить, что
производительность по основному сценарию (приложение + реальный файл) отличается от тестового (библиотека + генератор)
незначительно. Кажется, что вариант с генератором на несколько процентов быстрее, но более тонкий анализ показывает,
что это не так, и разница в показателях объясняется разным временем инициализации.[^nio-boost]

[^nio-boost]: Интересно также отметить, что реализация файлового ввода-вывода через NIO (`FileChannel`) значительно
ускоряет программу, а через `FileInputStream`, наоборот, замедляет. Я-то думал, потоки из стандартной библиотеки
давным-давно переписаны так, чтобы под капотом использовать всё тот же NIO, но выходит, что нет. Ещё интереснее, что
`FileInputStream` даже медленнее, чем перенаправление файла в `STDIN`.

По причинам, указанным выше, замеры производительности на больших входах (`BI02_Performance`) проводились только
для связки библиотека + генератор. В этих тестах 8 млрд. адресов обрабатываются примерно за 2000 секунд, что означает
250 нс на строчку, или **54 МБ/с**.

По сравнению с прошлой версией программы, ускорение более чем двукратное. Но это всё ещё недостаточно хорошо. 


### Компонентные бенчмарки

<details>
<summary>Сырые данные</summary>

#### Windows

    Benchmark                    (dataset)  Mode  Cnt     Score      Error  Units
    BC01_Initialization.v1_init        N/A  avgt   60    96.299 ±   11.747  ms/op
    BC02_Reader.v0                          avgt   60    65.703 ±    4,828  ns/op
    BC02_Reader.v1_standard                 avgt   60   595.623 ±   33.494  ns/op
    BC02_Reader.v2_lightweight              avgt   60   138.681 ±    9.179  ns/op
    BC03_Parser.v0                          avgt   60   101.620 ±    4.608  ns/op
    BC03_Parser.v1_mutableLine              avgt   60   140.469 ±    8.604  ns/op
    BC04_AddressSet.v0                      avgt   60     3.582 ±    0.364  ns/op
    BC04_AddressSet.v1_bitScale             avgt   60     8.065 ±    0.071  ns/op

#### Linux

    Benchmark                    (dataset)  Mode  Cnt     Score   Error  Units
    BC01_Initialization.v1_init        N/A  avgt   60    79.524 ± 0.222  ms/op
    BC02_Reader.v1_standard                 avgt   60   554.111 ± 3.441  ns/op
    BC02_Reader.v2_lightweight              avgt   60    88.210 ± 0.206  ns/op
    BC03_Parser.v0                          avgt   60    70.432 ± 0.629  ns/op
    BC03_Parser.v1_mutableLine              avgt   60    87.194 ± 0.350  ns/op
    BC04_AddressSet.v0                      avgt   60     3.450 ± 0.110  ns/op
    BC04_AddressSet.v1_bitScale             avgt   60     7.943 ± 0.046  ns/op

</details>

В нашей программе время тратится на две вещи: ввод-вывод и вычисления. Первое — это безальтернативный библиотечный
код, бенчмаркать который не слишком интересно, а вот вторым занимается уже наш собственный код, и его быстродействие
я проанализировал детально. Логически вычисления разбиваются на три этапа, на каждый из которых написан собственный
бенчмарк:

  - `BC02_Reader` — декодирование бинарных данных в текстовую форму;
  - `BC03_Parser` — парсинг IP-адресов;
  - `BC04_AddressSet` — учёт каждого адреса в структуре данных.

Суммарная длительность каждого из этапов пропорциональна объему входа. Кроме того, существует постоянная составляющая,
связанная с инициализацией всех частей программы, она измеряется бенчмарком `BC01_Initialization`.

Входными данными в бенчмарках выступала случайная выборка из 1000 адресов (13.9 КБ), предварительно загруженная
в память, чтобы избежать издержек IO. С непосредственными результатами экспериментов можно ознакомится под спойлером
в начале раздела, а выводы я изложу прямо здесь.

  1. Обработка каждого адреса занимает 127 нс, плюс 78 мс тратится единоразово на инициализацию. Ещё раз: это только
     обработка, без учёта загрузки или генерации, поэтому это число меньше того, что мы видели в интегральном бенчмарке.

  2. Разница между двумя цифрами, — а это почти те же 120+ нс, — объясняется затратами на ввод-вывод. Причём это
     время сжирает не ОС (она-то как раз может делать свою работу [фантастически быстро](https://mazzo.li/posts/fast-pipes.html))
     и не железо (даже дешёвые диски на SATA III выдают по 500 МБ/с, т.е. примерно одну строчку за 29 нс),
     а Java-машина. Жирный намёк на то, чтобы задуматься об оптимизации ввода-вывода.

  3. А вот в части вычислений в программе не осталось откровенно узких мест. Большую часть времени теперь занимает
     простой доступ к памяти. Это делается через интерфейсы `Reader.read` и `InputStream.read` для универсальности,
     но в итоге всё равно сводится к простому доступу к массиву (в бенчмарке этот массив создаётся явно, а в реальном
     коде в качестве него выступает внутренний буферу потока, разницы почти нет). Без того, чтобы разворотить весь
     дизайн, что-то радикально улучшить здесь будет затруднительно.

[Bloom_filter]: https://en.wikipedia.org/wiki/Bloom_filter
[Continuation-passing_style]: https://en.wikipedia.org/wiki/Continuation-passing_style
[Factory]: https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)
[Finite_state_machine]: https://en.wikipedia.org/wiki/Finite-state_machine
[Parser_combinator]: https://en.wikipedia.org/wiki/Parser_combinator
[Recursive_descent_parser]: https://en.wikipedia.org/wiki/Recursive_descent_parser
[Visitor_pattern]: https://en.wikipedia.org/wiki/Visitor_pattern