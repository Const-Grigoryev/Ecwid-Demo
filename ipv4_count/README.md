IPv4 Count
==========

Дан простой текстовый файл с IPv4 адресами. Одна строка – один адрес, примерно так:

```
145.67.23.4
8.34.5.23
89.54.3.124
89.54.3.124
3.45.71.5
...
```

Файл в размере не ограничен и может занимать десятки и сотни гигабайт.

Необходимо посчитать количество __уникальных адресов__ в этом файле, затратив как можно меньше памяти и времени.
Существует "наивный" алгоритм решения данной задачи (читаем строка за строкой, кладем строки в HashSet), желательно
чтобы ваша реализация была лучше этого простого, наивного алгоритма.

Немного деталей:
- По всем вопросам смело писать на join@ecwid.com
- Использовать можно только возможности стандартной библиотеки Java/Kotlin
- Писать нужно на Java (версия 11 и выше) или Kotlin.
- В задании должен быть рабочий метод main(), это должно быть готовое приложение, а не просто библиотека
- Сделанное задание необходимо разместить на GitHub

---
Прежде чем отправить задание, имеет смысл проверить его вот на этом [файле](https://ecwid-vgv-storage.s3.eu-central-1.amazonaws.com/ip_addresses.zip).
Внимание – файл весит около 20Gb, а распаковывается приблизительно в 120Gb.


Заметки по реализации
---------------------

1. Программу можно использовать как в режиме пользовательского приложения (класс `IPv4CountApp`), так и в режиме
   библиотеки (класс `IPv4Count`). Класс `IPv4CountApp` сам по себе занимается только соблюдением протокола ОС,
   а всю реальную работу делегирует движку `IPv4Count`.
   
2. Общий интерфейс приложения соответствует таковому для большинства Unix-утилит:
     - входом по умолчанию является стандартный поток ввода;
     - результат печатается в стандартный поток вывода;
     - ошибки, буде они случатся, валятся в `STDERR`;
     - поддерживаются разные коды завершения: 0 — всё прошло относительно гладко, –1 — случилась фатальная ошибка.

3. Программа работает в одном потоке, и это осознанное архитектурное решение. В зависимости от модели SSD, произвольный
   доступ к файлам может быть медленнее последовательного в 2–10 раз, что сведёт на нет весь потенциальный выигрыш
   от распараллеливания. В целом, многопоточное решение возможно в рамках эксперимента, но потребует переработки всего
   проекта, что вряд ли целесообразно.

4. Сердцем алгоритма является класс `BitScale`. Логически он представляет собой массив булевых значений, каждое из
   которых соответствует одному возможному адресу из пространства IPv4: «истина» означает, что адрес присутствует
   в просмотренной части списка, «ложь» — что отсутствует. Физически эти значения упакованы в «слова» по 64 штуки.
   Поскольку объём адресного пространства IPv4 составляет 2³², весь битовый массив имеет размер 2²⁹ байт, или 512 МБ.
   
5. Хотя 512 МБ вполне влезает в память современных машин, дизайн кода допускает замену битового массива какой-нибудь
   более экономной структурой данных, например, [фильтром Блума][Bloom_filter]. При этом удастся получить выигрыш
   в потреблении памяти (и, вероятно, быстродействии — благодаря уменьшению количества cache misses), пожертвовав
   точностью подсчёта.

6. Класс `BitScale` можно расширить, добавив методы для его представления в виде стандартного списка `List<Boolean>`
   или множества `Set<Long>`. Для данной задачи это не нужно, так как потребует большого количества дополнительной
   работы. Однако такой задел на будущее оставлен намеренно: эта структура данных довольно универсальна и хорошо
   подходит для повторного использования.

7. Другой важный компонент — парсер IP-адресов. Деталям его реализации посвящена [отдельная глава](#парсер-ip-адресов).
   Принципиально лишь то, что он выполнен на [конечном автомате][Finite_state_machine], построенном вручную — это
   традиционное, хорошо зарекомендовавшее себя решение для такого рода задач. Альтернативами могли бы быть:
     - использование ANTLR или аналогичного инструмента для генерации кода;
     - библиотека [комбинаторных парсеров][Parser_combinator];
     - [рекурсивный парсер][Recursive_descent_parser];
     - спагетти-парсер.
   
8. Для перекодирования бинарного входного потока в текст используется самодельный `LightweightInputStreamReader`.
   Он гораздо быстрее, чем стандартный `InputStreamReader`, за счёт отказа от поддержки разнообразных кодировок
   и возможности работы в многопоточном окружении. Он также не требует никаких дополнительных аллокаций при чтении
   (за исключением методов, читающих в массив, которыми я всё равно не пользуюсь). Единственная фича, которая в нём
   есть, — унификация различных символов разрыва строки, — сохранена ради преемственности с предыдущей версией,
   использовавшей `LineNumberReader`. 


### Парсер IP-адресов

#### Дизайн парсера: реализация

При разработке парсера основной акцент был сделан на скорость его работы. Такая расстановка приоритетов заставила
избегать высокоуровневых абстракций и чрезвычайно внимательно относиться к расходованию памяти. 

Так как по условию утилита должна спокойно переваривать файлы размером 120 ГБ (то есть около 8 млрд. строк),
создавать временные объекты в основном цикле программы было бы *крайне* нежелательно: даже один такой объект на строчку
слишком сильно нагрузил бы сборщик мусора. В частности, я сознательно отказался от стандартного `String`-а и очень
удобного в других обстоятельствах метода `Reader.readLine`. Ведь он при каждом вызове создаёт по объекту, а то и по два:
собственно `String` и массив символов в нём!

В итоге парсер пришлось писать в несколько старомодном C-подобном стиле, с изменяемыми переменными, управляющими
флагами, колбэками и большим `switch`-ем внутри. Поэтому в коде непросто разобраться с первого взгляда, даже
несмотря на подробные комментарии, что может затруднить его поддержку. Зато с точки зрения расхода памяти парсер
безупречен: в основном цикле моего кода нет ни единого `new`!

К сожалению, того же нельзя сказать про библиотечный код. Во-первых, стандартный `InputStreamReader` внутри себя
всё-таки создаёт один небольшой объект при каждом заполнении буфера. Во-вторых, он сам по себе довольно медленный
из-за необходимости переноса данных между разнотипными буферами. Для решения этой проблемы я просто написал свой
`LightweightInputStreamReader` минимальным набором методов.


#### Дизайн парсера: интерфейс

Парсер был переосмыслен с момента прошлого релиза. Если там парсер — отдельный класс с не вполне понятным состоянием,
то сейчас парсер — это отдельный метод `parseLine`, подмешанный к `IPv4LineVisitor` (в Kotlin я бы сделал extension
method). Причем здесь visitor? Сейчас объясню.

В принципе, задача парсера состоит в классификации каждой строчки входного файла как корректной (содержащей валидный
IP-адрес), некорректной (содержащей синтаксическую ошибку или просто не имеющей отношения к делу текст) или просто
пустой. В функциональных языках для такого рода классификаций используют тип-сумму и pattern matching, в ООП —
наследование классов и [паттерн *visitor*][Visitor_pattern]. *Visitor* — это наш «pattern matching дома», причём
особенно его любят именно в контексте парсинга и разного прочего компиляторостроения, хотя область его применения
этим не ограничивается. С практической же точки зрения, visitor («посетитель») — просто объект, содержащий по методу
на каждый из вариантов, допустимых классификацией, а сам акт классификации («посещение») всегда сводится к вызову
одного (и только одного!) из этих методов.

Однако вопреки тому, что пишут в книжках, visitor-у совершенно необязательно работать с объектами из одной иерархии.
Вполне достаточно того, чтобы у них было какое-нибудь единое представление, которое можно анализировать; например,
в виде текстовой строки. Это как раз наш случай: метод `parseLine` считывает одну строчку, разбирает и классифицирует
её и вызывает, в зависимости от результата, один из методов-продолжений[^continuation] `address`, `mistake` или
`nothing`. Никакой промежуточный объект при этом создавать не требуется! (Помните про цель добиться нуля аллокаций
на строчку?)

[^continuation]: Ещё одно умное слово. *Visitor* — это пример техники под названием [continuation-passing style (CPS)][Continuation-passing_style],
когда функция (в нашём случае `parseLine`) не возвращаёт значение напрямую, а спрашивает вызывающую сторону, что та
собиралась делать с ним, и делает это сама. Вот это «что вы собираетесь делать с результатом» и называется
_продолжением_ (continuation). На самом деле, продолжение — это обычный колбэк, который просто передаётся в функцию
дополнительным параметром; отсюда, собственно, и название. У нас продолжений несколько, и передаются они через `this`,
но суть всё равно та же. Кстати, через CPS можно эмулировать и другие фичи, которых нет в вашем любимом языке: ленивые
вычисления, исключения, кортежи, корутины, даже монады. Более того, зачастую даже в языках, в которых эти фичи есть,
под капотом они именно так и работают!

С другой стороны, *visitor* достаточно гибок, чтобы при необходимости *можно* было создать объект, представляющий
строчку с адресом, любого вида. Это открывает возможности для переиспользования кода. Например, если нам потребуется
неизменяемое представление, можно реализовать интерфейс `IPv4LineVisitor` в фабрике или билдере. Даже никакие адаптеры
не нужны: методы-продолжения суть *в точности* фабричные методы или методы, конфигурирующие билдер (см. пример кода
в тесте [*IPv4LineVisitorTest.kt*](src/test/kotlin/dev/aspid812/ipv4_count/impl/IPv4LineVisitorTest.kt#L16)).
А в данном проекте используется изменяемое представление `MutableIPv4Line`: в нём продолжения являются обычными
setter-ами.

Пару слов о недостатках такой реализации. Пуристы могут обратить внимание, что у нас каждая строчка требует вызова
двух интерфейсных методов, и один из них почти наверняка не будет оптимизирован виртуальной машиной. Причём очевидно,
что в поставленной задаче можно обойтись и без этого. Что ж, действительно, я рассматривал альтернативный вариант
дизайна, в котором парсер упаковывал прочитанный адрес и код ошибки в один `long` и просто возвращал его `return`-ом.
Но мне так и не удалось получить от него статистически значимый прирост производительности, и я решил, что несколько
потенциально сэкономленных тактов процессора не стоят того, чтобы отказываться от универсальности решения и гарантий,
предоставляемых системой типов.


Что дальше?
-----------

Как можно улучшить код или дополнить функционал утилиты:

- [ ] Поддержка разных кодировок. Со стороны пользователя это будет выглядеть как необязательный параметр командной
  строки: `-e cp1251`, например.

- [X] Кодировку по умолчанию сменить на более легковесную однобайтовую самоделку, в которой были бы только цифры, точки
  и переводы строк. Потенциально, это может очень сильно забустить производительность. *UPD:* сделано в v1.1, ускорение
  ×3.4.

- [ ] Прямое чтение из файла (или нескольких), а не из `STDIN`. Опять же, как параметры командной строки: `file1.txt
  file2.txt file3.txt`.

- [ ] После этого можно будет поэкспериментировать с более продвинутыми техниками: прямым маппингом файлов в память,
  параллельным чтением в несколько потоков, двойной буферизацией. Однако усилий это потребует колоссальных, а будет ли
  хоть какой-то практический выхлоп, неясно.

- [ ] Расширенный синтаксис. Разрешить комментарии и пробельные символы, ~~поддержать IPv6~~ (хотя нет, для этого
  придётся переделывать `BitScale`). Короче, тут есть где разгуляться фантазии.

- [ ] Более детальные сообщения об ошибках. Сейчас, по сути, их всего три (*UPD:* а было-то два — прогресс!):
    - **Invalid octet value** — переполнение октета, семантическая ошибка;
    - **Malformed address (too short)** — строчка содержит меньше четырёх октетов, синтаксическая ошибка;
    - **Unexpected character** — любая другая ошибка в синтаксисе.

- [X] Редизайн интерфейса `IPv4Parser`. Претензии к существующему дизайну и варианты их разрешения обсуждаются
  в [соответствующем разделе](#дизайн-парсера-интерфейс). *UPD:* сделано в v1.1.

- [ ] Отображать номер строчки в сообщении об ошибке.

- [X] Рефакторинг конечного автомата. Пока что смысл `State`-ов остаётся немного туманным, и неочевидно, почему
  выполняются инварианты. *UPD:* сделано в v1.1.

- [ ] Рефакторинг бенчмарков. В первой версии иерархия классов получилась очень запутанной, имеет смысл группировать
  бенчмарки по типу входных данных, а не по use case.


Бенчмаркинг
-----------

Бенчмаркинг в данной задаче преследует две цели: оценить производительность программы на файлах большого объёма
(около 120 ГБ) и выявить места для дальнейшей оптимизации. Соответственно, бенчмарки разделены на две большие группы:
«интегральные» измеряют время работы программы в целом, «компонентные» — её отдельных частей.

Тестирование проводилось на машине со следующей конфигурацией:

  - Intel i7-4500U CPU (4 cores @ 1.80 GHz);
  - 8 GB RAM (DDR3 1600 MHz);
  - 2 TB SATA-III SSD;
  - Microsoft Windows 10 + HotSpot JVM 17.0.11 (64-bit);
  - Ubuntu Linux 23.10.1 + OpenJDK 17.0.9-ea (64-bit).


### Интегральные бенчмарки

<details>
<summary>Сырые данные</summary>

**Дисклеймер:** приведённые данные актуальны для версии 1.0. Текущая версия ещё не проходила полный бенчмаркинг. 

#### Windows

    Benchmark                              (lines)  Mode  Cnt      Score     Error  Units
    ApplicationBenchmark.n00_generateOnly       1K    ss           0.444             s/op
    ApplicationBenchmark.n00_generateOnly      25K    ss           0.431             s/op
    ApplicationBenchmark.n00_generateOnly       1M    ss           1.274             s/op
    ApplicationBenchmark.n00_generateOnly      16M    ss          14.031             s/op
    ApplicationBenchmark.n01_liveInput          1K    ss           0.726             s/op
    ApplicationBenchmark.n01_liveInput         25K    ss           0.842             s/op
    ApplicationBenchmark.n01_liveInput          1M    ss           3.255             s/op
    ApplicationBenchmark.n01_liveInput         16M    ss          41.650             s/op
    ApplicationBenchmark.n02_fileInput          1K    ss           0.552             s/op
    ApplicationBenchmark.n02_fileInput         25K    ss           0.564             s/op
    ApplicationBenchmark.n02_fileInput          1M    ss           1.101             s/op
    ApplicationBenchmark.n02_fileInput         16M    ss           8.771             s/op
    EngineBenchmark.n00_generateOnly            1K    ss           0.016             s/op
    EngineBenchmark.n00_generateOnly           25K    ss           0.031             s/op
    EngineBenchmark.n00_generateOnly            1M    ss           0.098             s/op
    EngineBenchmark.n00_generateOnly           16M    ss           0.830             s/op
    EngineBenchmark.n01_liveInput               1K    ss           0.345             s/op
    EngineBenchmark.n01_liveInput              25K    ss           0.364             s/op
    EngineBenchmark.n01_liveInput               1M    ss           1.079             s/op
    EngineBenchmark.n01_liveInput              16M    ss           8.518             s/op
    EngineBenchmark.n02_fileInput               1K    ss           0.333             s/op
    EngineBenchmark.n02_fileInput              25K    ss           0.351             s/op
    EngineBenchmark.n02_fileInput               1M    ss           0.836             s/op
    EngineBenchmark.n02_fileInput              16M    ss           7.494             s/op
    LoadBenchmark.n01_measure_1k               N/A    ss   15      0.082 ±   0.002   s/op
    LoadBenchmark.n02_measure_25k              N/A    ss   10      0.102 ±   0.005   s/op
    LoadBenchmark.n03_measure_1m               N/A    ss    5      0.789 ±   0.076   s/op
    LoadBenchmark.n04_measure_16m              N/A    ss    3     11.422 ±   1.915   s/op
    LoadBenchmark.n05_measure_200m             N/A    ss         137.288             s/op
    LoadBenchmark.n06_measure_8b               N/A    ss        5470.897             s/op

#### Linux

    Benchmark                              (lines)  Mode  Cnt      Score     Error  Units
    ApplicationBenchmark.n00_generateOnly       1K    ss           0.431             s/op
    ApplicationBenchmark.n00_generateOnly      25K    ss           0.446             s/op
    ApplicationBenchmark.n00_generateOnly       1M    ss           1.372             s/op
    ApplicationBenchmark.n00_generateOnly      16M    ss          14.998             s/op
    ApplicationBenchmark.n01_liveInput          1K    ss           0.723             s/op
    ApplicationBenchmark.n01_liveInput         25K    ss           0.775             s/op
    ApplicationBenchmark.n01_liveInput          1M    ss           2.710             s/op
    ApplicationBenchmark.n01_liveInput         16M    ss          32.529             s/op
    ApplicationBenchmark.n02_fileInput          1K    ss           0.509             s/op
    ApplicationBenchmark.n02_fileInput         25K    ss           0.575             s/op
    ApplicationBenchmark.n02_fileInput          1M    ss           1.118             s/op
    ApplicationBenchmark.n02_fileInput         16M    ss           8.497             s/op
    EngineBenchmark.n00_generateOnly            1K    ss           0.021             s/op
    EngineBenchmark.n00_generateOnly           25K    ss           0.029             s/op
    EngineBenchmark.n00_generateOnly            1M    ss           0.127             s/op
    EngineBenchmark.n00_generateOnly           16M    ss           0.964             s/op
    EngineBenchmark.n01_liveInput               1K    ss           0.417             s/op
    EngineBenchmark.n01_liveInput              25K    ss           0.441             s/op
    EngineBenchmark.n01_liveInput               1M    ss           1.268             s/op
    EngineBenchmark.n01_liveInput              16M    ss          12.857             s/op
    EngineBenchmark.n02_fileInput               1K    ss           0.390             s/op
    EngineBenchmark.n02_fileInput              25K    ss           0.416             s/op
    EngineBenchmark.n02_fileInput               1M    ss           0.973             s/op
    EngineBenchmark.n02_fileInput              16M    ss           8.324             s/op
    LoadBenchmark.n01_measure_1k               N/A    ss   15      0.102 ±   0.004   s/op
    LoadBenchmark.n02_measure_25k              N/A    ss   10      0.124 ±   0.008   s/op
    LoadBenchmark.n03_measure_1m               N/A    ss    5      0.888 ±   0.078   s/op
    LoadBenchmark.n04_measure_16m              N/A    ss    3     12.474 ±   5.776   s/op
    LoadBenchmark.n05_measure_200m             N/A    ss         127.603             s/op
    LoadBenchmark.n06_measure_8b               N/A    ss        6038.040             s/op

</details>

Так как на моем ноутбуке нет свободных 120 ГБ, вместо физического файла пришлось использовать рандомный генератор,
но для сравнения я также взял несколько настоящих файлов меньшего размера (от 1 тыс. до 16 млн. строк, т.е. от 15 КБ
до 240 МБ). Я предполагал, что узким местом станет именно ввод-вывод, а генератор, запущенный в отдельном процессе,
будет выплёвывать строчки быстрее, чем основная программа (которую я далее буду называть просто _счётчиком_) будет
парсить их. Таким образом, использование генератора не должно было повлиять на результаты измерений. Однако эта моя
гипотеза не выдержала проверки. Соответствующие бенчмарки собраны в классе `ApplicationBenchmark`[^jmh-misuse]:

[^jmh-misuse]: Здесь генератор и счётчик запускаются в отдельных процессах с помощью `ProcessBuilder`. Понятно,
что JMH не предназначен для подобных сценариев, но здесь нам и не нужен точный результат, достаточно самых грубых
оценок.

  1. `n02_fileInput` измеряет производительность счётчика на реальных физических файлах. С файлом из 16 млн. адресов
     программа справляется примерно за 8 сек. На это значение будем ориентироваться.
  2. `n00_generatorOnly` запускает генератор и перенаправляет его вывод в */dev/null*. Даже в таком режиме генератор
     оказывается почти вдвое медленнее основной программы!
  3. `n01_liveInput` — генератор и счётчик, соединенные через пайп. Оказалось, что это не просто медленнее, чем
     генератор и счётчик по отдельности, а медленнее *в разы*. Интересно, кстати, что и в Linux, и в Windows картина
     с пайпами качественно одинаковая; возможно, я просто не умею их готовить.

С другой стороны, под контролем JMH в пределах одной виртуальной машины (и даже одного потока) генератор и счётчик
вместе показали гораздо более стабильный результат. По сути, здесь счётчик работал «в режиме библиотеки». Этот
сценарий оценивается бенчмарками из `EngineBenchmark`:

   1. `n00_generatorOnly` измеряет производительность генератора отдельно от счётчика. Видно, что она почти на порядок
      превосходит производительность счётчика, то есть вклад генератора в общее время работы пренебрежимо мал. Именно
      мы и добивались.   
   2. `n02_fileInput`, как и в прошлый раз, берёт в качестве входных данных реальный файл. Видно, что цифры времени
      работы в этом случае более-менее совпадает с теми, что были получены в режиме приложения. Следовательно,
      тестирование производительности в режиме библиотеки — вполне адекватная альтернатива бенчмаркингу всей программы
      целиком.
   3. `n01_liveInput` позволяет убедиться, что генератор и счётчик вместе дают предсказуемый результат. В режиме
      приложения, как мы помним, именно с этим были основные проблемы.

Наконец, `LoadBenchmark` измеряет производительность на по-настоящему больших входах. Концептуально это в точности
`EngineBenchmark.n01_liveInput`, просто вынесенный в отдельный класс для удобства. Цифры, полученные этим бенчмарком,
используются для проверки детальной модели (см. ниже).

Видно также, что производительность в Linux систематически отстаёт примерно на 10%. Вероятно, это связано с настройками
электропитания и общей загруженностью системы. В следующих версиях нужно будет постараться нивелировать эту разницу.


### Компонентные бенчмарки

<details>
<summary>Сырые данные</summary>

#### Windows

    Benchmark                  (dataset)  Mode  Cnt      Score     Error  Units
    BitScaleBenchmark.measure             avgt   12      0.008 ±   0.001  us/op
    InitBenchmark.measure            N/A  avgt   12  78373.175 ± 997.937  us/op
    ParserBenchmark.measure               avgt   12      0.080 ±   0.008  us/op
    ReaderBenchmark.measure               avgt   12      0.101 ±   0.007  us/op


#### Linux

    Benchmark                  (dataset)  Mode  Cnt      Score     Error  Units
    BitScaleBenchmark.measure             avgt   12      0.010 ±   0.001  us/op
    InitBenchmark.measure            N/A  avgt   12  92606.888 ± 500.351  us/op
    ParserBenchmark.measure               avgt   12      0.084 ±   0.001  us/op
    ReaderBenchmark.measure    [############### ДАННЫЕ УДАЛЕНЫ ###############]

</details>

Общее время работы программы складывается из следующих вещей:

  - получение бинарных данных из источника (реального файла или генератора);
  - декодирование в текстовую форму;
  - парсинг IP-адресов;
  - учёт каждого адреса в структуре данных.

Каждая из этих величин пропорциональна объему входа. Кроме того, существует постоянная составляющая, связанная
с инициализацией всех компонентов.

Чтением данных из файла занимается операционная система, и она делает это очень быстро. Фактически, естественным
ограничением здесь выступают возможности железа, а не софта. Например, наиболее распространённые сейчас SSD на SATA 3
работают на скоростях около 500 МБ/с — для нас это 35 адресов в микросекунду, или 0.029 мкс на строчку. Как мы уже
выяснили, производительность Java-кода (более 0.5 мкс на строчку) и близко не подбирается к этим числам.

Остальные составляющие тестируются собственными бенчмарками, чьи результаты спрятаны под спойлером в начале раздела.
Выводы из них можно сделать такие:

  1. Время работы программы может быть оценено как 0.19 мкс на строчку, плюс 78 мс единоразово на инициализацию.
     В более привычных терминах это означает производительность **75 МБ/с**.
  2. В системе нет явного "бутылочного горлышка", время работы поровну распределяется между двумя компонентами
     примерно одинаковой сложности. Следовательно, ресурс для оптимизации здесь почти исчерпан.
  3. Тем не менее до теоретического предела в 500 МБ/с ещё далеко. Способы дальнейшего повышения быстродействия
     существуют, но требуют качественно другого подхода к решению задачи.

[Bloom_filter]: https://en.wikipedia.org/wiki/Bloom_filter
[Continuation-passing_style]: https://en.wikipedia.org/wiki/Continuation-passing_style
[Factory]: https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)
[Finite_state_machine]: https://en.wikipedia.org/wiki/Finite-state_machine
[Parser_combinator]: https://en.wikipedia.org/wiki/Parser_combinator
[Recursive_descent_parser]: https://en.wikipedia.org/wiki/Recursive_descent_parser
[Visitor_pattern]: https://en.wikipedia.org/wiki/Visitor_pattern